% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/search_features.r
\name{search_features}
\alias{search_features}
\title{Find tokens using a Lucene-like search query}
\usage{
search_features(tc, keyword = NA, condition = NA, code = NA,
  queries = NULL, feature = "word", condition_once = F,
  keyword_filter = NULL, keep_false_condition = F, only_last_mword = T,
  verbose = F)
}
\arguments{
\item{tc}{a tCorpus object}

\item{keyword}{The keyword part of the query, see explanation in query_tutorial markdown or in details below}

\item{condition}{The condition part of the query, see explanation in query_tutorial markdown or in details below}

\item{code}{The code given to the tokens that match the query (usefull when looking for multiple queries)}

\item{queries}{Alternatively, a data.frame can be given that contains a "keyword" column, and optionally columns for the "condition", "code" and "condition_once" paramters.}

\item{condition_once}{logical. If TRUE, then if an keyword satisfies its conditions once in an article, all keywords within that article are coded.}

\item{keyword_filter}{A logical vector that indicates which tokens can match an keyword. Can for instance be used to only select tokens that are proper names (using POS tagging) when looking for people.}

\item{keep_false_condition}{if True, the keyword hits for which the condition was not satisfied are also returned, with an additional column that indicates whether the condition was satisfied. This can be used to investigate whether the condition is too strict, causing false negatives}

\item{only_last_mword}{If TRUE, then if multiword keywords are used (i.e. using double quotes, for instance "the united states"), only return the index of the last word. Note that if this is set to FALSE, it affects the occurence frequency, which is often a bad idea (e.g., counting search hits, word co-occurence analysis)}
}
\description{
Search tokens in a tokenlist using a query that consists of an keyword, and optionally a condition. For a detailed explanation of the query language please consult the query_tutorial markdown file. For a quick summary see the details below.
}
\details{
Note that the query arguments (keyword, condition, code, condition_once) can be vectors to search multiple queries at once. Alternatively, the queries argument can be used to pass these arguments in a data.frame


Brief summary of the query language

The keyword:
\itemize{
   \item{is the actual feature that has to be found in the token}
   \item{can contain multiple words with OR statement (and empty spaces are also considered OR statements)}
   \item{CANNOT contain AND or NOT statements (this is what the condition is for)}
   \item{accepts the ? wildcard, which means that any single character can be used in this place}
   \item{accepts the * wildcard, which means that any number of characters can be used in this place}
 }

The condition:
\itemize{
   \item{has to be TRUE for the keyword to be accepted. Thus, if a condition is given, the query can be interpreted as: keyword AND condition}
   \item{can contain complex boolean statements, using AND, OR and NOT statements, and using parentheses}
   \item{accepts the ? and * wildcards}
   \item{can be specified for a maximum word distance of the keyword. The terms in the condition are looked up within this word distance. Individual terms can be given a word distance using the ~ symbol, where "word~50" means that "word" is looked up within 50 words of the keyword.}
}

Parameters:
\itemize{
   \item{condition_once -> if TRUE, then if the condition is satisfied at least once in an article, all occurences of the keyword are accepted. }
}
}

